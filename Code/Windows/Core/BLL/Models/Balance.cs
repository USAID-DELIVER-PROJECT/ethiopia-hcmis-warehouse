
// Generated by MyGeneration Version # (1.3.0.3)

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Linq;
using BLL.Models;
using DAL;
using System.Data.SqlClient;

namespace BLL
{
	/// <summary>
	/// A proxy class to deal with any Item balance related functionality
	/// </summary>
	/// the inheritance is just not right.
	public class Balance : _Mode
	{
		#region private properties.
		private Dictionary<int, DataTable> _CurrentStockStatus = new Dictionary<int, DataTable>();
		private int _itemId;
		private int _storeId;
		private int? _unitID;
		#endregion
		/// <summary>
		/// Gets the average monthly consumption of an item
		/// This method considers the logical store
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		[Obsolete("Returns a code calculated AMC")]
		public Int64 CalculateAmc(int itemId, int storeId, int month,int year)
		{

			//int range = GeneralInfo.Current.AMCRange;
			//Int64 cons = 0;
			//IssueDoc iss = new IssueDoc();
			//int yr = year;// (month > 10) ? year - 1 : year;
			////TODO: read this from the SOH stored proc
			//DateTime dt1 = new DateTime(yr,month,DateTime.DaysInMonth(yr,month));
			//DateTime dt2 = dt1.AddMonths(-range);
			//range = GetAvailableNoOfMonths(itemId, storeId, dt2, dt1);
			
			//cons = iss.GetIssuedQuantityByDateRange(itemId, storeId, dt2, dt1);

			//Int64 amc = cons / range;
			return 0;// amc;
		}

		/// <summary>
		/// Gets Average Monthly consumption, without considering logical stores
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		[Obsolete("Returns 0, is not working at all.")]
		public Int64 CalculateAmcAll(int itemId, int month, int year)
		{

			//int range = GeneralInfo.Current.AMCRange;
			//Int64 cons = 0;
			//IssueDoc iss = new IssueDoc();
			//int yr = (month > 10) ? year - 1 : year;

			//DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
			//DateTime dt2 = dt1.AddMonths(-range);
			//range = Balance.GetAvailableNoOfMonthsInAllStores(itemId, dt2, dt1);

			//cons = iss.GetIssuedQuantityByDateRangeAll(itemId, dt2, dt1);

			//Int64 amc = cons / range;
			return 0;// amc;
		}

		/// <summary>
		/// Gets how much months in, the stock was available in store
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="storeId"></param>
		/// <param name="dt1"></param>
		/// <param name="dt2"></param>
		/// <returns></returns>
		public static int GetAvailableNoOfMonths(int itemId, int storeId, DateTime dt1, DateTime dt2)
		{
			Balance bal = new Balance();
			int count = 1;
			bal.FlushData();
            bal.LoadFromRawSql(HCMIS.Repository.Queries.Balance.SelectGetAvailableNoOfMonths(itemId, storeId, dt1, dt2));
			DateTime dtLast = (bal.DataTable.Rows.Count > 0) ? bal.GetDateTime("Date") : dt2;
			TimeSpan tDiff = dt2 - dtLast;
			count = tDiff.Days / 30;
			count = count + 1;
			return count;
		}


	    /// <summary>
		/// Get available number of Months the item was in store in all logical stores
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="dt1"></param>
		/// <param name="dt2"></param>
		/// <returns></returns>
		public static int GetAvailableNoOfMonthsInAllStores(int itemId, DateTime dt1, DateTime dt2)
		{
			Balance balance = new Balance();

			int count = 1;
			balance.FlushData();
			balance.LoadFromRawSql(HCMIS.Repository.Queries.Balance.SelectGetAvailableNoOfMonthsInAllStores(itemId, dt1, dt2));
			DateTime dtLast = (balance.DataTable.Rows.Count > 0) ? balance.GetDateTime("Date") : dt2;
			TimeSpan tDiff = dt2 - dtLast;
			count = tDiff.Days / 30;
			count = (count > 0) ? count : 1;
			return count;
		}
        
	    /// <summary>
		/// Gets SOH of a specific item for the end of the specified Ethipian Fiscal Month Item
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		public decimal GetSoh(int itemId, int unitID, int storeId, int month, int year)
		{

			LoadStockOnHandByItem(itemId, storeId, unitID , month, year);
			
			return this.RowCount > 0 ? Convert.ToDecimal(this.GetColumn("SOH")) : 0;
		}

		///<summary>
		/// Returns the Usable Stock
		///</summary>
		///<param name="itemId"></param>
		///<param name="storeId"></param>
		///<param name="month"></param>
		///<param name="year"></param>
		///<returns></returns>
		
		public int GetUsableStock(int itemId, int storeId, int? unitID , int month, int year)
		{
		
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			
			{

				LoadStockOnHandByItem(itemId, storeId, unitID, month, year);
				_itemId = itemId;
				_storeId = storeId;
				_unitID = unitID;
			}
			if (this.RowCount == 0)
			{
				return 0;
			}

			return Convert.ToInt32(this.DataRow["Dispatchable"]);


		}

		/// <summary>
		/// Loads the stock on hand by item.
		/// </summary>
		/// <param name="itemId">The item id.</param>
		/// <param name="storeId">The store id.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <param name="month">The month.</param>
		/// <param name="year">The year.</param>
		private void LoadStockOnHandByItem(int itemId, int storeId, int? unitID, int month, int year)
		{
			////HACK: Pagume
			////TO FIX: Date needs to be handled correctly
			if (month == 13)
			{
				year++;
				month = 1;
			}
			ListDictionary ld = new ListDictionary
										{
											{"@storeid", storeId},
											{"@month", month},
											{"@year", year},
											{"@days", DateTime.DaysInMonth(year, month)},
											{"@itemid", itemId},
											{"@unitid", unitID}
										};

			this.LoadFromSql("SOHByItem", ld, CommandType.StoredProcedure);
		}


		///<summary>
		/// Returns the Usable Stock
		/// Uses QuantityLeft Column to determine the results.
		///</summary>
		///<param name="itemID"></param>
		///<param name="storeID"></param>
		///<param name="month"></param>
		///<param name="year"></param>
		///<returns></returns>
		public int GetUsableStock(int itemID, int storeID, int? unitID, int? manufacturerID,int? physicalStoreID, DateTime? expiryDate)
		{
		    var query = HCMIS.Repository.Queries.Balance.SelectGetUsableStock(itemID, storeID, unitID, physicalStoreID,
		                                                                      manufacturerID, expiryDate);

			this.LoadFromRawSql(query);
			var quantityLeft=this.GetColumn("QL");
			if (quantityLeft != null && quantityLeft.ToString() != "")
				return int.Parse(quantityLeft.ToString()) < 0 ? 0 : int.Parse(quantityLeft.ToString());
			return 0;
		}
        
	    /// <summary>
		/// Gets the total price of the items in stock.
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		public double GetSohPrice(int itemId, int storeId,int commodityType, int month, int year)
		{
			var report = (Balance.GetSohForAllItems(storeId,commodityType, year, month).AsEnumerable().Where(
				v => Convert.ToInt32(v["ID"]) == itemId));
			if (report.Count() > 0)
			{
				return Convert.ToInt32(report.First()["Price"]);
			}
			return 0;
		}

	   /// <summary>
	   /// Gets the list of items that have normal stock status
	   /// </summary>
	   /// <param name="storeId"></param>
	   /// <param name="month"></param>
	   /// <param name="year"></param>
	   /// <returns></returns>
        public static DataView GetNormalStock(int storeId, int commodityType, int month, int year)
		{
			var report = (from v in Balance.GetSohForAllItems(storeId,commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Normal"
						  select v).AsDataView();
			return report;
		}

		/// <summary>
		/// Gets list of items with quantity less than the minimum
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
        public static DataView GetBelowMin(int storeId, int commodityType, int month, int year)
		{
			var report = (from v in Balance.GetSohForAllItems(storeId,commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Below EOP"
						  select v).AsDataView();
			return report;
		}

	   
		/// <summary>
		/// Gets list of near Emergency Order Products
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
        public static DataView GetNearEop(int storeId, int commodityType, int month, int year)
		{
			var report = (from v in GetSohForAllItems(storeId,commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Near EOP"
						  select v).AsDataView();
			return report;
		}


		/// <summary>
		/// Gets list of Items that are below Emergency order point
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
        public static DataView GetBelowEop(int storeId, int commodityType, int month, int year)
		{
			var report = (from v in GetSohForAllItems(storeId, commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Below EOP"
						  select v).AsDataView();
			return report;
		}

		/// <summary>
		/// Gets list of items that are stocked out.
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		public static DataView GetStockOut(int storeId,int commodityType, int month, int year)
		{
			var report = (from v in GetSohForAllItems(storeId, commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Stock Out"
						  select v).AsDataView();
			return report;
		}


		/// <summary>
		///  Gets list of items that are stocked out from items that were ever received
		/// 
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
        public static DataView GetReceivedStockOut(int storeId, int commodityType, int month, int year)
		{
			var report = (from v in GetSohForAllItems(storeId, commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Stock Out" && v["EverReceived"].ToString() == "1"
						  select v).AsDataView();
			return report;
		}

		/// <summary>
		/// Get list of items that are over stocked.
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="month"></param>
		/// <param name="year"></param>
		/// <returns></returns>
		public static DataView GetOverStock(int storeId, int commodityType,int month, int year)
		{
			var report = (from v in GetSohForAllItems(storeId, commodityType, year, month).AsEnumerable()
						  where v["Status"].ToString() == "Over Stocked"
						  select v).AsDataView();
			return report;
		}

		/// <summary>
		///  Stock on hand
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <returns></returns>
		public static DataTable GetSohForAllItems(int storeId, int commodityType ,int year, int month)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			
			Balance bal = new Balance();
			//HACK: Pagume
			//TOFIX: Date needs to be handled correctly
			if (month == 13)
			{
				year++;
				month = 1;
			}
            ListDictionary ld = new ListDictionary
									{
										{"@storeid", storeId}, 
										{"@month", month},
										{"@year", year},
										{"@days", DateTime.DaysInMonth(year, month)},
                                        {"@CommodityType",commodityType}
									};

			bal.LoadFromSql("SOH", ld, CommandType.StoredProcedure);
			return bal.DataTable;
		}

		/// <summary>
		/// Gets the soh for all items by ware house.
		/// </summary>
		/// <param name="storeId">The store id.</param>
		/// <param name="year">The year.</param>
		/// <param name="month">The month.</param>
		/// <param name="WarehouseID">The warehouse ID.</param>
		/// <returns></returns>
		public static DataTable GetSohForAllItemsByWareHouse(int storeId, int year, int month,int WarehouseID)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error

			Balance bal = new Balance();
			//HACK: Pagume
			//TO FIX: Date needs to be handled correctly
			if (month == 13)
			{
				year++;
				month = 1;
			}
			ListDictionary ld = new ListDictionary
									{
										{"@storeid", storeId}, 
										{"@WarehouseID", WarehouseID},
										{"@month", month},
										{"@year", year},
										{"@days", DateTime.DaysInMonth(year, month)}
									};

			bal.LoadFromSql("SOHByWarehouse", ld, CommandType.StoredProcedure);
			return bal.DataTable;
		}


		/// <summary>
		/// Makes the stock calculations stored proc.
		/// </summary>
		/// <param name="currentMonth">The current month.</param>
		/// <param name="currentYear">The current year.</param>
		/// <param name="orderDetailID">The order detail ID.</param>
		/// <param name="storeID">The store ID.</param>
		/// <param name="unpricedOrPricedOrBoth">The unpriced or priced or both.</param>
		/// <param name="markStockoutBit">if set to <c>true</c> [mark stockout bit].</param>
		/// <param name="usableStock">The usable stock.</param>
		/// <param name="approved">The approved.</param>
		/// <param name="availableQuantity">The available quantity.</param>
		[Obsolete("This has not been implemented")]
		public static void MakeStockCalculationsStoredProc(int currentMonth, int currentYear, int orderDetailID, int storeID, int unpricedOrPricedOrBoth, bool markStockoutBit, out int usableStock, out int approved, out int availableQuantity)
		{
			usableStock = approved = availableQuantity = 0;

			Balance bal = new Balance();
			if (currentMonth == 13)
			{
				currentYear++;
				currentMonth = 1;
			}
			ListDictionary ld = new ListDictionary
			{
				{"@currentMonth",currentMonth},
				{"@currentYear",currentYear},
				{"@currentDay",DateTime.DaysInMonth(currentYear,currentMonth)},
				{"@orderDetailID",orderDetailID},
				{"@storeID",storeID},
				{"@unpricedOrPricedOrBoth",unpricedOrPricedOrBoth},
				{"@markStockoutBit",markStockoutBit?1:0}                
			};

			SqlParameter pUs=new SqlParameter();
			pUs.Direction = ParameterDirection.Output;
			pUs.ParameterName = "@usableStock";
			pUs.Value = usableStock;
			ld.Add(pUs.ParameterName, pUs.Value);

			SqlParameter pApp = new SqlParameter();
			pApp.Direction = ParameterDirection.Output;
			pApp.ParameterName = "@approved";
			pApp.Value = approved;
			ld.Add(pApp.ParameterName, pApp.Value);

			SqlParameter pAv = new SqlParameter();
			pAv.Direction = ParameterDirection.Output;
			pAv.ParameterName = "@availableQuantity";
			pAv.Value = availableQuantity;
			ld.Add(pAv.ParameterName, pAv.Value);

			bal.LoadFromSqlNoExec("MakeStockCalculations", ld);

			usableStock = Convert.ToInt32(ld["@usableStock"]);// Convert.ToInt32(pUs.Value);
			approved = Convert.ToInt32(ld["@approved"]); //Convert.ToInt32(pApp.Value);
			availableQuantity = Convert.ToInt32(ld["@availableQuantity"]); //Convert.ToInt32(pAv.Value);
		}

		/// <summary>
		/// Gets stock on hand categoriezed by supplier
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <returns></returns>
		public static DataTable GetBalanceBySupplierId(int storeId, int year, int month)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			Balance bal = new Balance();
			ListDictionary ld = new ListDictionary();
			ld.Add("@storeid", storeId);
			ld.Add("@month", month);
			ld.Add("@year", year);
			ld.Add("@days", DateTime.DaysInMonth(year, month));

			bal.LoadFromSql("SOHBySupplier", ld, CommandType.StoredProcedure);
			return bal.DataTable;
		}

		/// <summary>
		/// Get Balance by Expiry Date
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <returns></returns>
		public DataTable GetBalanceByExpiryDate(int storeId, int year, int month,int commodityType)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			
			ListDictionary ld = new ListDictionary
									{
										{"@storeid", storeId},
										{"@month", month},
										{"@year", year},
										{"@days", DateTime.DaysInMonth(year, month)},
                                        {"@commodityType",commodityType}
									};


			this.LoadFromSql("SOHByExpiryDate", ld, CommandType.StoredProcedure);
			return this.DataTable;
		}

		/// <summary>
		/// Get balance by batch no
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <returns></returns>
        public DataTable GetBalanceByBatch(int storeId, int year, int month, int commodityType)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			
			ListDictionary ld = new ListDictionary
									{
										{"@storeid", storeId},
										{"@month", month},
										{"@year", year},
										{"@days", DateTime.DaysInMonth(year, month)},
                                        {"@CommodityType", commodityType}
									};

			//this.LoadFromSqlNoExec("SOH", ld);
			this.LoadFromSql("SOHByExpiryBatchDate", ld, CommandType.StoredProcedure);
			return this.DataTable;
		}

		/// <summary>
		/// Gets the bin card for an item
		/// </summary>
		/// <param name="itemId"></param>
		/// <returns></returns>
		public static DataView GetBinCard(int storeId, int itemId, int? unitID, int fiscalYear)
		{
			var ld = new ListDictionary();
			ld.Add("@ItemID", itemId);
			ld.Add("@UnitID",unitID);
			ld.Add("@StoreID", storeId);
			ld.Add("@FiscalYear", fiscalYear);

			Balance bal = new Balance();
			bal.LoadFromSql("rpt_BinCard", ld, CommandType.StoredProcedure);
			bal.Rewind();
			int Balance = 0;
			while (!bal.EOF)
			{
				Balance += Convert.ToInt32(bal.GetColumn("Balance"));
				bal.SetColumn("Balance", Balance);
				bal.MoveNext();
			}
			return bal.DefaultView;
		}

		/// <summary>
		/// Gets bin card by supplier
		/// </summary>
		/// <param name="itemId"></param>
		/// <param name="supplierId"></param>
		/// <returns></returns>
		public static DataView GetBinCard(int storeId, int itemId, int? unitID, int fiscalYear, int supplierId)
		{            
			var ld = new ListDictionary();
			ld.Add("@ItemID", itemId);
			ld.Add("@UnitID", unitID);
			ld.Add("@StoreID", storeId);
			ld.Add("@FiscalYear", fiscalYear);
			ld.Add("@SupplierID", supplierId);

			Balance bal = new Balance();
			bal.LoadFromSql("Rpt_BinCardBySupplier", ld, CommandType.StoredProcedure);

			bal.Rewind();
			int Balance = 0;
			while (!bal.EOF)
			{
				Balance += Convert.ToInt32(bal.GetColumn("Balance"));
				bal.SetColumn("Balance", Balance);
				bal.MoveNext();
			}
			return bal.DefaultView;
		}


		/// <summary>
		/// Gets the bin card by warehouse.
		/// </summary>
		/// <param name="storeId">The store id.</param>
		/// <param name="itemId">The item id.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <param name="fiscalYear">The fiscal year.</param>
		/// <param name="physicalStoreTypeID">The physical store type ID.</param>
		/// <returns></returns>
		public static DataView GetBinCardByWarehouse(int storeId, int itemId, int? unitID, int fiscalYear, int physicalStoreTypeID)
		{
			var ld = new ListDictionary();
			ld.Add("@ItemID", itemId);
			ld.Add("@UnitID", unitID);
			ld.Add("@StoreID", storeId);
			ld.Add("@FiscalYear", fiscalYear);
			ld.Add("@Warehouse", physicalStoreTypeID);

			Balance bal = new Balance();
			bal.LoadFromSql("[Rpt_BinCardByWarehouse]", ld, CommandType.StoredProcedure);

			bal.Rewind();
			decimal Balance = 0;
			while (!bal.EOF)
			{
				Balance += Convert.ToDecimal(bal.GetColumn("Balance"));
				bal.SetColumn("Balance", Balance);
				bal.MoveNext();
			}
			return bal.DefaultView;
		}
        public static DataView GetBinCardByDate(int storeId, int itemId, int? unitID, int physicalStoreTypeID,DateTime fromDate,DateTime toDate)
        {
            var ld = new ListDictionary();
            ld.Add("@ItemID", itemId);
            ld.Add("@UnitID", unitID);
            ld.Add("@StoreID", storeId);
            ld.Add("@fromdate",fromDate);
            ld.Add("@toDate",toDate);
            ld.Add("@Warehouse", physicalStoreTypeID);

            Balance bal = new Balance();
            bal.LoadFromSql("[Rpt_BinCardByDate]", ld, CommandType.StoredProcedure);

            bal.Rewind();
            int Balance = 0;
            while (!bal.EOF)
            {
                Balance += Convert.ToInt32(bal.GetColumn("Balance"));
                bal.SetColumn("Balance", Balance);
                bal.MoveNext();
            }
            return bal.DefaultView;
        }
        public static DataView GetStockCardByDate(int storeId, int itemId, int? unitID, int physicalStoreTypeID, int manufactuerID, DateTime fromDate, DateTime toDate)
        {
            var ld = new ListDictionary();
            ld.Add("@ItemID", itemId);
            ld.Add("@UnitID", unitID);
            ld.Add("@StoreID", storeId);
            ld.Add("@fromdate", fromDate);
            ld.Add("@toDate", toDate);
            ld.Add("@Warehouse", physicalStoreTypeID);
            ld.Add("@Manufacturer", manufactuerID);
            Balance bal = new Balance();
            bal.LoadFromSql("[Rpt_StockCardByDate]", ld, CommandType.StoredProcedure);

            bal.Rewind();
            int Balance = 0;
            while (!bal.EOF)
            {
                Balance += Convert.ToInt32(bal.GetColumn("Balance"));
                bal.SetColumn("Balance", Balance);
                bal.MoveNext();
            }
            return bal.DefaultView;
        }
        public static DataView GetStockCardByWarehouse(int storeId, int itemId, int? unitID, int fiscalYear, int physicalStoreTypeID,int manufactuerID)
        {
            var ld = new ListDictionary();
            ld.Add("@ItemID", itemId);
            ld.Add("@UnitID", unitID);
            ld.Add("@StoreID", storeId);
            ld.Add("@FiscalYear", fiscalYear);
            ld.Add("@Warehouse", physicalStoreTypeID);
            ld.Add("@Manufacturer",manufactuerID);

            Balance bal = new Balance();
            bal.LoadFromSql("[Rpt_StockCard]", ld, CommandType.StoredProcedure);

            bal.Rewind();
            decimal Balance = 0;
            while (!bal.EOF)
            {
                Balance += Convert.ToDecimal(bal.GetColumn("Balance"));
                bal.SetColumn("Balance", Balance);
                bal.MoveNext();
            }
            return bal.DefaultView;
        }

		/// <summary>
		/// Gets Price for items that are in stock.
		/// </summary>
		/// <param name="storeId"></param>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <returns></returns>
		public static DataTable PriceOfAllItems(int storeId, int year, int month)
		{

			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error
			
			Balance bal = new Balance();
			var query = HCMIS.Repository.Queries.Balance.SelectPriceOfAllItems(storeId);
			bal.LoadFromRawSql(query);
			return bal.DataTable;
		}
        
	    /// <summary>
		/// Gets the quantity left.
		/// </summary>
		/// <param name="storeID">The store ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <returns></returns>
		public static long GetQuantityLeft(int storeID, int itemID, int unitID)
		{
			var query = HCMIS.Repository.Queries.Balance.SelectGetQuantityLeft(storeID, itemID, unitID);
			BLL.Balance bal = new Balance();
			bal.LoadFromRawSql(query);
			return Convert.ToInt64(bal.GetColumn("QL"));
		}

	    /// <summary>
		/// Gets the un priced quantity.
		/// </summary>
		/// <param name="itemID">The item ID.</param>
		/// <param name="storeID">The store ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <param name="manufacturerID">The manufacturer ID.</param>
		/// <param name="physicalStoreID">The physical store ID.</param>
		/// <param name="preferredExpiryDate">The preferred expiry date.</param>
		/// <returns></returns>
		public Int64 GetUnPricedQuantity(int itemID, int storeID, int? unitID, int? manufacturerID,int? physicalStoreID, DateTime? preferredExpiryDate)
		{
			string query;
			
			if (BLL.Settings.IsCenter) //If it is center, we don't require it to have been received by delivery notes.
			{
			    query =
			        HCMIS.Repository.Queries.Balance.SelectGetUnPricedQuantityForCenter(itemID, storeID, unitID, manufacturerID,
			                                                                            physicalStoreID, preferredExpiryDate);
			}
			else
			{
			    query =
			        HCMIS.Repository.Queries.Balance.SelectGetUnPricedQuantityForHub(itemID, storeID, unitID, manufacturerID,
			                                                                         physicalStoreID, preferredExpiryDate);
			}
			BLL.Balance bal = new Balance();
			bal.LoadFromRawSql(query);

			try
			{
				if (bal.IsColumnNull("UQ"))
					return 0;
				return Convert.ToInt64(bal.GetColumn("UQ"));
			}
			catch
			{ 
				return 0; 
			}
		}

	    /// <summary>
		/// Gets the picklisted value for facility.
		/// </summary>
		/// <param name="userID">The user ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <returns></returns>
		public DataTable GetPicklistedValueForFacility(int userID, int itemID, int unitID)
		{
			this.FlushData();
			var query = HCMIS.Repository.Queries.Balance.SelectGetPicklistedValueForFacility(userID, itemID, unitID);
			this.LoadFromRawSql(query);
			return this.DataTable;
		}

	    public static DataTable GetReservedItemsWithAmount(int modeID)
        {
            BLL.Balance bal = new Balance();
            var query = HCMIS.Repository.Queries.Balance.SelectGetReservedItemsWithAmount(modeID, BLL.OrderStatus.Constant.PICK_LIST_GENERATED, BLL.OrderStatus.Constant.PICK_LIST_CONFIRMED);
            bal.LoadFromRawSql(query);
            while (!bal.EOF)
            {
                bal.SetColumn("Difference", DateTimeHelper.GetDateSpan(Convert.ToDateTime(bal.GetColumn("SavedDate")),
                                                                        DateTimeHelper.ServerDateTime));
                bal.MoveNext();
            }
            return bal.DataTable;
        }

	    /// <summary>
		/// Gets the approved value for facility per activity.
		/// </summary>
		/// <param name="storeID">The store ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <returns></returns>
		public DataTable GetApprovedValueForFacilityPerActivity(int storeID, int itemID, int unitID)
		{
			this.FlushData();
			var query = HCMIS.Repository.Queries.Balance.SelectGetApprovedValueForFacilityPerActivity(storeID, itemID, unitID);
			this.LoadFromRawSql(query);
			return this.DataTable;
		}

	    /// <summary>
		/// Gets the approved value for facility.
		/// </summary>
		/// <param name="userID">The user ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <returns></returns>
		public DataTable GetApprovedValueForFacility(int userID, int itemID, int unitID)
		{
			this.FlushData();
			var query = HCMIS.Repository.Queries.Balance.SelectGetApprovedValueForFacility(userID, itemID, unitID);
			this.LoadFromRawSql(query);
			return this.DataTable;
		}
        
	    /// <summary>
		/// Gets the SOH for an item.
		/// </summary>
		/// <param name="storeID">The store ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitID">The unit ID.</param>
		/// <returns></returns>
		public DataTable GetSOHForAnItem(int storeID, int itemID, int unitID)
		{
			this.FlushData();
			LoadStockOnHandByItem(itemID,storeID,unitID,EthiopianDate.EthiopianDate.Now.Month,EthiopianDate.EthiopianDate.Now.Year);
			//DataTable tbl = GetSohForAllItems(storeID, EthiopianDate.EthiopianDate.Now.Year, EthiopianDate.EthiopianDate.Now.Month);
			//DataTable x = (from y in tbl.AsEnumerable()
			//               where Convert.ToInt32(y["ID"]) == itemID && Convert.ToInt32(y["UnitID"]) == unitID
			//               select y).AsDataView().ToTable();
			return this.DataTable;
		}



		/// <summary>
		/// Gets all SOH for print out.
		/// </summary>
		/// <param name="userId">The user id.</param>
		/// <param name="year">The year.</param>
		/// <param name="month">The month.</param>
		/// <returns></returns>
		public static DataTable GetAllSOHForPrintOut(int userId, int year, int month)
		{
			DataTable datatable = null;

		    Activity stores = new Activity();
            stores.LoadByUserID(userId);
			Balance balance = new Balance();
			while(!stores.EOF){
				string account = stores.FullActivityName;
				if(datatable == null){
                    var query = HCMIS.Repository.Queries.Balance.SelectGetAllSOHForPrintOutInitial(stores.ID);
					balance.LoadFromRawSql( query );
					datatable = balance.DataTable;
					datatable.Columns.Add("Account");
					foreach (DataRow dr in datatable.Rows)
					{
						dr["Account"] = account;
					}
				}else{
                    var query = HCMIS.Repository.Queries.Balance.SelectGetAllSOHForPrintOut(stores.ID);
					balance.LoadFromRawSql(query);
					DataTable dtbl = balance.DataTable;
					dtbl.Columns.Add("Account");
					foreach(DataRow dr in dtbl.Rows){
						dr["Account"] = account;
						datatable.ImportRow(dr);
					}
				}
				stores.MoveNext();
			}
			return datatable;
		}

	    /// <summary>
		/// Gets the type of the soh for all items by.
		/// </summary>
		/// <param name="storeId">The store id.</param>
		/// <param name="type">The type.</param>
		/// <param name="userId">The user id.</param>
		/// <param name="year">The year.</param>
		/// <param name="month">The month.</param>
		/// <returns></returns>
		public static DataTable GetSohForAllItemsByType(int storeId, string type, int userId, int year, int month,int categoryID)
		{
			// this has to return the balance of all item as the name discribes
			// this is there fore working based on the stock on hand STORED procedure, if  the stored procedure for some reason threw an error

			Balance bal = new Balance();
			//HACK: Pagume
			//TO FIX: Date needs to be handled correctly
			if (month == 13)
			{
				year++;
				month = 1;
			}
			ListDictionary ld = new ListDictionary
									{
										{"@storeid", storeId}, 
										{"@month", month},
										{"@year", year},
										{"@userid", userId},
										{"@type",type},
										{"@days", DateTime.DaysInMonth(year, month)},
                                        {"@commodityTypeID", categoryID}
									};
            
            bal.LoadFromSql("SOHByAccount", ld, CommandType.StoredProcedure);
		    return bal.DataTable;
		}

		/// <summary>
		/// Gets the items available for approval.
		/// </summary>
		/// <param name="setting">The setting.</param>
		/// <param name="currentMonth">The current month.</param>
		/// <param name="currentYear">The current year.</param>
		/// <param name="storeID">The store ID.</param>
		/// <param name="itemID">The item ID.</param>
		/// <param name="unitid">The unitid.</param>
		/// <param name="preferedExpiry">The prefered expiry.</param>
		/// <param name="preferredManufacturer">The preferred manufacturer.</param>
		/// <param name="preferredPhysicalStoreID">The preferred physical store ID.</param>
		/// <param name="usableStock">The usable stock.</param>
		/// <param name="approved">The approved.</param>
		/// <param name="availableQuantity">The available quantity.</param>
		public void GetItemsAvailableForApproval(PriceSettings setting, int currentMonth, int currentYear, int storeID, int itemID, int? unitid, DateTime? preferedExpiry, int? preferredManufacturer, int? preferredPhysicalStoreID,int userID,out decimal usableStock, out decimal approved, out decimal availableQuantity)
		{
		    var query = HCMIS.Repository.Queries.Balance.SelectGetItemsAvailableForApproval(userID, storeID, itemID, unitid,
		                                                                                    setting ==
		                                                                                    PriceSettings.DELIVERY_NOTE_ONLY,
		                                                                                    BLL.Settings.
		                                                                                        IssueUnPricedCommodities,
		                                                                                    BLL.Settings.
		                                                                                        DoNotIssueNearExpiryItems,
		                                                                                    preferedExpiry,
		                                                                                    preferredManufacturer,
		                                                                                    preferredPhysicalStoreID);
			this.LoadFromRawSql(query);
			if (this.RowCount > 0 && !this.IsColumnNull("Usable"))
			{
				usableStock = Convert.ToDecimal(this.GetColumn("Usable"));
				approved = Order.GetApprovedQuantity(setting, storeID,itemID, unitid, preferedExpiry, preferredManufacturer, preferredPhysicalStoreID);
				availableQuantity = usableStock - approved;
			}
			else
			{
				usableStock = 0;
				approved = 0;
				availableQuantity = 0;
			}
			
		}

 
        public static DataTable GetStockStatusByAccount(int accountID,bool showUnitPrice = false)
        {
            string query;
            if(showUnitPrice)
            {
                 query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccountShowUnitPrice(accountID);
               
            }
            else
            {
               query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccountHideUnitPrice(accountID);
               
                
            }
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            balance.AddColumn("LineNo", typeof (int));
            int i = 1;
            while (!balance.EOF)
            {
                balance.SetColumn("LineNo",i++);
                balance.MoveNext();
            }
            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByMode()
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByMode();
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);

            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByAccountDamagedExcluded()
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccountDamagedExcluded();
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);

            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByAccount()
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccount();
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);

            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByModeDamagedExcluded()
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByModeDamagedExcluded();
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);

            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByAccountDamagedExcluded(int AccountID,bool showUnitPrice = false)
        {
            string query;
            if(showUnitPrice)
            {
                query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccountDamagedExcludedShowUnitPrice(AccountID);
            }
            else
            {
                query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByAccountDamagedExcludedHideUnitPrice(AccountID);
            }

            
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            balance.AddColumn("LineNo", typeof(int));
            int i = 1;
            while (!balance.EOF)
            {
                balance.SetColumn("LineNo", i++);
                balance.MoveNext();
            }
            return balance.DataTable;
        }

	    public static DataTable GetStockStatusByPhysicalStore(int physicalStoreID, int activityID, bool showStockout)
	    {
	        var query = HCMIS.Repository.Queries.Balance.SelectGetStockStatusByPhysicalStore(physicalStoreID, activityID,
	                                                                                         showStockout);
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DataTable;
        }

	    public static DataTable GetCountSheetByPhysicalStore(int physicalStoreID, int activityID, bool showStockout)
        {
            string stockOutQuery = "";
            if (!showStockout)
            {
                stockOutQuery = HCMIS.Repository.Queries.Balance.SelectGetCountSheetByPhysicalStoreShowStockOut(physicalStoreID, activityID, stockOutQuery);
            }

            var query = HCMIS.Repository.Queries.Balance.SelectGetCountSheetByPhysicalStoreHideStockOut(physicalStoreID, activityID, stockOutQuery);
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DataTable;
        }

	    public static DataTable GetCountSheetByPhysicalStoreWithBatchExpiry(int physicalStoreID, int activityID, bool showStockout, bool showLocations)
	    {
	        var query =
	            HCMIS.Repository.Queries.Balance.SelectGetCountSheetByPhysicalStoreWithBatchExpiryHideStockOut(
	                physicalStoreID, activityID, showLocations, showStockout);
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DataTable;
        }

	    public static DataTable GetBalanceByPhysicalStore(int physicalStoreID, int activityID, bool showStockout)
	    {
	        var query = HCMIS.Repository.Queries.Balance.SelectGetBalanceByPhysicalStore(physicalStoreID, activityID,
	                                                                                     showStockout);
            Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DataTable;
        }


	    public static DataView GetSOHReportForFinance(int warehouseID, int activityID)
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGetSOHReportForFinance(warehouseID, activityID);
            BLL.Balance balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }

	    public static BLL.Models.StockAvailabilityStatistics GetStockAvailabilityStats(int month, int year)
        {
            var commodityType= new CommodityType();
            commodityType.LoadAll();
            var activity = new BLL.Activity();
            activity.LoadByMode(Mode.Constants.HEALTH_PROGRAM);

            var overstocked = 0;
            var nearEOP = 0;
            var belowEOP = 0;
            var stockedOut = 0;
            var normal = 0;

            while(!commodityType.EOF)
            {
                activity.Rewind();
                while(!activity.EOF)
                {
                    DataTable tbl = GetSohForAllItems(activity.ID,
                                                      commodityType.ID, year, month);
                    overstocked += (from y in tbl.AsEnumerable() where y["Status"].ToString() == "Over Stocked" select y).Count();
                    nearEOP += (from y in tbl.AsEnumerable() where y["Status"].ToString() == "Near EOP" select y).Count();
                    belowEOP += (from y in tbl.AsEnumerable() where y["Status"].ToString() == "Below EOP" select y).Count();
                    stockedOut += (from y in tbl.AsEnumerable() where y["Status"].ToString() == "Stock Out" select y).Count();
                    normal += (from y in tbl.AsEnumerable() where y["Status"].ToString() == "Normal" select y).Count();

                    activity.MoveNext();
                }
                commodityType.MoveNext();
            }

            var statistics = new StockAvailabilityStatistics(overstocked, normal, nearEOP, belowEOP, stockedOut);
            return statistics;
        }

        public void LoadQuantityNotReceive(int itemId, int itemUnitID,int modeID)
        {
            var query = HCMIS.Repository.Queries.Balance.SelecthubGIT(itemId,itemUnitID, modeID);
            this.LoadFromRawSql(query);
            //var balance = new Balance();
            //var queryRQ = HCMIS.Repository.Queries.Balance.Selecthubrequest(itemId, itemUnitID, modeID);
            //balance.LoadFromRawSql(queryRQ);
            //this.SetColumn("Requested", balance.Getdecimal("Requested"));
            //var balanceApp = new Balance();
            //var queryAP = HCMIS.Repository.Queries.Balance.Selecthubapproved(itemId, itemUnitID, modeID);
            //balanceApp.LoadFromRawSql(queryAP);
            //this.Setdecimal("Approved", balanceApp.Getdecimal("Approved"));
        }

        public decimal GetTotalApprovedQuantityByItem(int orderId, int itemId, int itemUnitId, int modeId)
        {
            var query = HCMIS.Repository.Queries.Balance.SelectTotalApprovedQty( orderId,itemId, itemUnitId, modeId);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.Getdecimal("TotalRequested");
        }

        public DataView LoadHubRequested(int itemID ,int itemUnitID ,int modeID)
        {
            var query = HCMIS.Repository.Queries.Balance.SelectHubRequested(itemID ,itemUnitID,modeID);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }

        public DataView LoadHubApproved (int itemId, int itemUnitID,int modeID)
        {
            var query = HCMIS.Repository.Queries.Balance.SelectHubApproved(itemId, itemUnitID, modeID);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }

        public DataView LoadHubGIT(int itemId, int itemUnitID, int modeID)
        {
            var query = HCMIS.Repository.Queries.Balance.SelectGIT(itemId, itemUnitID, modeID);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }

        public decimal GoodInTransit
        {
            get { return Getdecimal("GIT"); }
        }

        public decimal RequestedQuantity
        {
            get { return Getdecimal("Requested"); }
        }

        public decimal ApprovedQuantity
        {
            get { return Getdecimal("Approved"); }
        }

        public DataTable GetSOHByMode(int modeID)
        {
            var query =
                String.Format(
                    @"      declare @amcrange int
	                        declare @min int
	                        declare @max int
	                        declare @eop float
	
select  @amcrange = AMCRange,@eop = EOP, @min = MIN, @max = MAX from GeneralInfo 

SELECT  Item.ID ItemID,ItemUnit.ID UnitID,Item.FullItemName ItemName,ItemUnit.Text ItemUnit, Requisition.Demand Demand
                                ,Cast(Sum(Case When ReceiveDoc.ExpDate > GetDate() then QuantityLeft/QtyPerPack else 0 End) as decimal) SOH
								, isNull(AMC.amc * @min,0) [Min],isNull(Amc.amc * @max,0) [Max],isNull(amc.Amc,0) AMC,Case When isNull(Amc.amc * @max,0) - Cast(Sum(Case When ReceiveDoc.ExpDate > GetDate() then QuantityLeft/QtyPerPack else 0 End) as decimal)< 0 Then 0 Else isNull(Amc.amc * @max,0) - Cast(Sum(Case When ReceiveDoc.ExpDate > GetDate() then QuantityLeft/QtyPerPack else 0 End) as decimal) End Requested
                                , isNull(DOS.StockedOutDays,0) StockedOutDays
                                FROM  ReceiveDoc 
		                                JOIN  vwGetAllItems AS Item ON ReceiveDoc.ItemID = Item.ID 
		                                JOIN  ItemUnit ON ReceiveDoc.UnitID = ItemUnit.ID 
		                                JOIN  vwAccounts AS Activity ON ReceiveDoc.StoreID = Activity.ActivityID
		                                Left JOIN (Select ItemID,UnitID,Sum(isNull(OrderDetail.Quantity,0)) Demand
					                                From [Order] 
							                                join OrderDetail on [Order].ID = OrderDetail.OrderID
					                                Where DATEDiff(MM,[Order].EurDate,GetDate()) < 3
                                                    Group by ItemID,UnitID) as Requisition
					                                On Requisition.ItemID = Item.ID and ItemUnit.ID = Requisition.UnitID
										Left Join(
													Select ItemID,UnitID,sum(IssueDoc.Quantity / IssueDoc.QtyPerPack)/@amcrange amc
													from IssueDoc Join vwAccounts Activity on IssueDoc.StoreId = Activity.ActivityID
													where Activity.ModeID = 2 and IssueDoc.ReceivingUnitID is not null and DATEDIFF(MM,IssueDoc.EurDate,GETDATE())<=@amcrange
													Group by ItemID,UnitID) as AMC	On AMC.ItemID = Item.ID and ItemUnit.ID = AMC.UnitID
                                        Left Join (select ItemID, UnitID, Sum(NumberOfDays) StockedOutDays 
                                                    from stockout
                                                    group by ItemID, UnitID
                                                    ) as DOS on DOS.ItemID = Item.ID and DOS.UnitID = ItemUnit.ID
                                Where Activity.ModeID = {0}
                                Group By Item.ID ,ItemUnit.ID ,Item.FullItemName,ItemUnit.Text,amc.amc,Requisition.Demand,DOS.StockedOutDays
								Order by ItemName", modeID);

            LoadFromRawSql(query);
            return DataTable;
        }

        public int DOS
        {
            get { return Getint("DOS"); }
        }

        public decimal TotalIssued
        {
            get { return Getdecimal("TotalIssued"); }
        }
   
	    public int FiscalYearDays
        {
            get { return Getint("FiscalYearDays"); }
        }





        public DataView GetBalanceByOrder(int orderID,int userId)
        {

            var query = HCMIS.Repository.Queries.Balance.SelectvwDispatchableItemByOrderID(orderID,userId);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }
        public DataView GetApprovedByOrderID(int orderID)
        {

            var query = HCMIS.Repository.Queries.Balance.SelectApprovedInformationByOrderID(orderID);
            var balance = new Balance();
            balance.LoadFromRawSql(query);
            return balance.DefaultView;
        }

        public DataView getOtherStockInformationByOrderID(int orderId)
        {
            return  new DataView();
        }
    }

    

}